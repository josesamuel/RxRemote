package io.reactivex.remote.internal;

import android.os.Bundle;
import android.os.IBinder;
import android.os.Parcel;
import android.os.Parcelable;
import android.os.Parcelable.Creator;
import android.os.RemoteException;

import java.util.Map;
import java.util.WeakHashMap;


/**
 * Wraps a remote {@link IBinder} that implements {@link RemoteEventListener} interface
 * <p>
 * Autogenerated by <a href="https://bit.ly/Remoter">Remoter</a>
 *
 * @see RemoteEventListener_Stub
 */
public class RemoteEventListener_Proxy implements RemoteEventListener {
    private static final String DESCRIPTOR = "io.reactivex.remote.internal.RemoteEventListener";

    private static final int REMOTER_EXCEPTION_CODE = -99999;

    private static final int TRANSACTION_onRemoteEvent_0 = IBinder.FIRST_CALL_TRANSACTION + 0;

    private static final int TRANSACTION_onCompleted_1 = IBinder.FIRST_CALL_TRANSACTION + 1;

    private static final int TRANSACTION_onError_2 = IBinder.FIRST_CALL_TRANSACTION + 2;

    private static final int TRANSACTION__getStubID = IBinder.FIRST_CALL_TRANSACTION + 3;

    private IBinder mRemote;

    private final int _binderID;

    private Map<Object, IBinder> stubMap = new WeakHashMap();

    /**
     * Initialize this {@link RemoteEventListener_Proxy} with the given {@link IBinder}
     *
     * @param binder An {@link IBinder} that exposes a remote {@link RemoteEventListener}
     */
    public RemoteEventListener_Proxy(IBinder binder) {
        this.mRemote = binder;
        this._binderID = __getStubID();
    }

    @Override
    public void onRemoteEvent(Bundle remoteData_0) {
        __checkProxy();
        Parcel data = Parcel.obtain();
        try {
            data.writeInterfaceToken(DESCRIPTOR);
            if (remoteData_0 != null) {
                data.writeInt(1);
                remoteData_0.writeToParcel(data, 0);
            } else {
                data.writeInt(0);
            }
            mRemote.transact(TRANSACTION_onRemoteEvent_0, data, null, IBinder.FLAG_ONEWAY);
        } catch (RemoteException re) {
            throw new RuntimeException(re);
        } finally {
            data.recycle();
        }
    }

    @Override
    public void onCompleted() {
        __checkProxy();
        Parcel data = Parcel.obtain();
        try {
            data.writeInterfaceToken(DESCRIPTOR);
            mRemote.transact(TRANSACTION_onCompleted_1, data, null, IBinder.FLAG_ONEWAY);
        } catch (RemoteException re) {
            throw new RuntimeException(re);
        } finally {
            data.recycle();
        }
    }

    @Override
    public void onError(Exception exception_0) {
        __checkProxy();
        Parcel data = Parcel.obtain();
        try {
            data.writeInterfaceToken(DESCRIPTOR);
            Class pClassexception_0 = getParcelerClass(exception_0);
            if (pClassexception_0 != null) {
                data.writeInt(1);
                data.writeString(pClassexception_0.getName());
                org.parceler.Parcels.wrap(pClassexception_0, exception_0).writeToParcel(data, 0);
            } else {
                data.writeInt(2);
                data.writeValue(exception_0);
            }
            mRemote.transact(TRANSACTION_onError_2, data, null, IBinder.FLAG_ONEWAY);
        } catch (RemoteException re) {
            throw new RuntimeException(re);
        } finally {
            data.recycle();
        }
    }


    /**
     * Register a {@link IBinder.DeathRecipient} to know of binder connection lose
     */
    public void linkToDeath(IBinder.DeathRecipient deathRecipient) {
        try {
            mRemote.linkToDeath(deathRecipient, 0);
        } catch (Exception ignored) {
        }
    }

    /**
     * UnRegisters a {@link IBinder.DeathRecipient}
     */
    public void unlinkToDeath(IBinder.DeathRecipient deathRecipient) {
        try {
            mRemote.unlinkToDeath(deathRecipient, 0);
        } catch (Exception ignored) {
        }
    }

    /**
     * Checks whether the remote process is alive
     */
    public boolean isRemoteAlive() {
        boolean alive = false;
        try {
            alive = mRemote.isBinderAlive();
        } catch (Exception ignored) {
        }
        return alive;
    }

    private Throwable checkException(Parcel reply) {
        int code = reply.readInt();
        Throwable exception = null;
        if (code != 0) {
            String msg = reply.readString();
            if (code == REMOTER_EXCEPTION_CODE) {
                exception = (Throwable) reply.readSerializable();
            } else {
                exception = new RuntimeException(msg);
            }
        }
        return exception;
    }

    private int __getStubID() {
        Parcel data = Parcel.obtain();
        Parcel reply = Parcel.obtain();
        int result;
        try {
            data.writeInterfaceToken(DESCRIPTOR);
            mRemote.transact(TRANSACTION__getStubID, data, reply, 0);
            Throwable exception = checkException(reply);
            if (exception != null) {
                throw (RuntimeException) exception;
            }
            result = reply.readInt();
        } catch (RemoteException re) {
            throw new RuntimeException(re);
        } finally {
            reply.recycle();
            data.recycle();
        }
        return result;
    }

    @Override
    public int hashCode() {
        return _binderID;
    }

    @Override
    public boolean equals(Object obj) {
        return (obj instanceof RemoteEventListener_Proxy) && obj.hashCode() == hashCode();
    }

    //@Override
    public void destroyStub(Object object) {
        if (object != null) {
            synchronized (stubMap) {
                IBinder binder = stubMap.get(object);
                if (binder != null) {
                    ((RemoterStub) binder).destroyStub();
                    stubMap.remove(object);
                }
            }
        }
    }

    private void __checkProxy() {
        if (mRemote == null) throw new RuntimeException("Trying to use a destroyed Proxy");
    }

    //@Override
    public void destroyProxy() {
        this.mRemote = null;
        synchronized (stubMap) {
            for (IBinder binder : stubMap.values()) {
                ((RemoterStub) binder).destroyStub();
            }
            stubMap.clear();
        }
    }

    private Class getParcelerClass(Object object) {
        if (object != null) {
            Class objClass = object.getClass();
            boolean found = false;
            while (!found && objClass != null) {
                try {
                    Class.forName(objClass.getName() + "$$Parcelable");
                    found = true;
                } catch (ClassNotFoundException ignored) {
                    objClass = objClass.getSuperclass();
                }
            }
            return objClass;
        }
        return null;
    }

    private Object getParcelerObject(String pClassName, Parcel data) {
        try {
            Parcelable p = null;
            Creator creator = (Creator) Class.forName(pClassName + "$$Parcelable").getField("CREATOR").get(null);
            Object pWrapper = creator.createFromParcel(data);
            return pWrapper.getClass().getMethod("getParcel", (Class[]) null).invoke(pWrapper);
        } catch (Exception ignored) {
            return null;
        }
    }


}
